// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/unkeyed/unkey-go/internal/utils"
	"github.com/unkeyed/unkey-go/models/components"
)

// V1MigrationsEnqueueKeysVariant - The algorithm for hashing and encoding, currently only sha256 and base64 are supported
type V1MigrationsEnqueueKeysVariant string

const (
	V1MigrationsEnqueueKeysVariantSha256Base64 V1MigrationsEnqueueKeysVariant = "sha256_base64"
)

func (e V1MigrationsEnqueueKeysVariant) ToPointer() *V1MigrationsEnqueueKeysVariant {
	return &e
}
func (e *V1MigrationsEnqueueKeysVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sha256_base64":
		*e = V1MigrationsEnqueueKeysVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V1MigrationsEnqueueKeysVariant: %v", v)
	}
}

// V1MigrationsEnqueueKeysHash - Provide either `hash` or `plaintext`
type V1MigrationsEnqueueKeysHash struct {
	// The hashed and encoded key
	Value string `json:"value"`
	// The algorithm for hashing and encoding, currently only sha256 and base64 are supported
	Variant V1MigrationsEnqueueKeysVariant `json:"variant"`
}

func (o *V1MigrationsEnqueueKeysHash) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

func (o *V1MigrationsEnqueueKeysHash) GetVariant() V1MigrationsEnqueueKeysVariant {
	if o == nil {
		return V1MigrationsEnqueueKeysVariant("")
	}
	return o.Variant
}

// V1MigrationsEnqueueKeysInterval - Unkey will automatically refill verifications at the set interval.
type V1MigrationsEnqueueKeysInterval string

const (
	V1MigrationsEnqueueKeysIntervalDaily   V1MigrationsEnqueueKeysInterval = "daily"
	V1MigrationsEnqueueKeysIntervalMonthly V1MigrationsEnqueueKeysInterval = "monthly"
)

func (e V1MigrationsEnqueueKeysInterval) ToPointer() *V1MigrationsEnqueueKeysInterval {
	return &e
}
func (e *V1MigrationsEnqueueKeysInterval) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "daily":
		fallthrough
	case "monthly":
		*e = V1MigrationsEnqueueKeysInterval(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V1MigrationsEnqueueKeysInterval: %v", v)
	}
}

// V1MigrationsEnqueueKeysRefill - Unkey enables you to refill verifications for each key at regular intervals.
type V1MigrationsEnqueueKeysRefill struct {
	// Unkey will automatically refill verifications at the set interval.
	Interval V1MigrationsEnqueueKeysInterval `json:"interval"`
	// The number of verifications to refill for each occurrence is determined individually for each key.
	Amount int64 `json:"amount"`
	// The day verifications will refill each month, when interval is set to 'monthly'
	RefillDay *float64 `json:"refillDay,omitempty"`
}

func (o *V1MigrationsEnqueueKeysRefill) GetInterval() V1MigrationsEnqueueKeysInterval {
	if o == nil {
		return V1MigrationsEnqueueKeysInterval("")
	}
	return o.Interval
}

func (o *V1MigrationsEnqueueKeysRefill) GetAmount() int64 {
	if o == nil {
		return 0
	}
	return o.Amount
}

func (o *V1MigrationsEnqueueKeysRefill) GetRefillDay() *float64 {
	if o == nil {
		return nil
	}
	return o.RefillDay
}

// V1MigrationsEnqueueKeysType - Deprecated, use `async`. Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
//
// https://unkey.dev/docs/features/ratelimiting - Learn more
//
// Deprecated type: This will be removed in a future release, please migrate away from it as soon as possible.
type V1MigrationsEnqueueKeysType string

const (
	V1MigrationsEnqueueKeysTypeFast       V1MigrationsEnqueueKeysType = "fast"
	V1MigrationsEnqueueKeysTypeConsistent V1MigrationsEnqueueKeysType = "consistent"
)

func (e V1MigrationsEnqueueKeysType) ToPointer() *V1MigrationsEnqueueKeysType {
	return &e
}
func (e *V1MigrationsEnqueueKeysType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fast":
		fallthrough
	case "consistent":
		*e = V1MigrationsEnqueueKeysType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V1MigrationsEnqueueKeysType: %v", v)
	}
}

// V1MigrationsEnqueueKeysRatelimit - Unkey comes with per-key fixed-window ratelimiting out of the box.
type V1MigrationsEnqueueKeysRatelimit struct {
	// Async will return a response immediately, lowering latency at the cost of accuracy.
	Async *bool `default:"true" json:"async"`
	// Deprecated, use `async`. Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	Type *V1MigrationsEnqueueKeysType `default:"fast" json:"type"`
	// The total amount of requests in a given interval.
	Limit int64 `json:"limit"`
	// The window duration in milliseconds
	Duration int64 `json:"duration"`
	// How many tokens to refill during each refillInterval.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	RefillRate *int64 `json:"refillRate,omitempty"`
	// The refill timeframe, in milliseconds.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	RefillInterval *int64 `json:"refillInterval,omitempty"`
}

func (v V1MigrationsEnqueueKeysRatelimit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *V1MigrationsEnqueueKeysRatelimit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *V1MigrationsEnqueueKeysRatelimit) GetAsync() *bool {
	if o == nil {
		return nil
	}
	return o.Async
}

func (o *V1MigrationsEnqueueKeysRatelimit) GetType() *V1MigrationsEnqueueKeysType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *V1MigrationsEnqueueKeysRatelimit) GetLimit() int64 {
	if o == nil {
		return 0
	}
	return o.Limit
}

func (o *V1MigrationsEnqueueKeysRatelimit) GetDuration() int64 {
	if o == nil {
		return 0
	}
	return o.Duration
}

func (o *V1MigrationsEnqueueKeysRatelimit) GetRefillRate() *int64 {
	if o == nil {
		return nil
	}
	return o.RefillRate
}

func (o *V1MigrationsEnqueueKeysRatelimit) GetRefillInterval() *int64 {
	if o == nil {
		return nil
	}
	return o.RefillInterval
}

type Keys struct {
	// To make it easier for your users to understand which product an api key belongs to, you can add prefix them.
	//
	// For example Stripe famously prefixes their customer ids with cus_ or their api keys with sk_live_.
	//
	// The underscore is automatically added if you are defining a prefix, for example: "prefix": "abc" will result in a key like abc_xxxxxxxxx
	//
	Prefix *string `json:"prefix,omitempty"`
	// The name for your Key. This is not customer facing.
	Name *string `json:"name,omitempty"`
	// The raw key in plaintext. If provided, unkey encrypts this value and stores it securely. Provide either `hash` or `plaintext`
	Plaintext *string `json:"plaintext,omitempty"`
	// Provide either `hash` or `plaintext`
	Hash *V1MigrationsEnqueueKeysHash `json:"hash,omitempty"`
	// The first 4 characters of the key. If a prefix is used, it should be the prefix plus 4 characters.
	Start *string `json:"start,omitempty"`
	// Your userâ€™s Id. This will provide a link between Unkey and your customer record.
	// When validating a key, we will return this back to you, so you can clearly identify your user from their api key.
	OwnerID *string `json:"ownerId,omitempty"`
	// This is a place for dynamic meta data, anything that feels useful for you should go here
	Meta map[string]any `json:"meta,omitempty"`
	// A list of roles that this key should have. If the role does not exist, an error is thrown
	Roles []string `json:"roles,omitempty"`
	// A list of permissions that this key should have. If the permission does not exist, an error is thrown
	Permissions []string `json:"permissions,omitempty"`
	// You can auto expire keys by providing a unix timestamp in milliseconds. Once Keys expire they will automatically be disabled and are no longer valid unless you enable them again.
	Expires *int64 `json:"expires,omitempty"`
	// You can limit the number of requests a key can make. Once a key reaches 0 remaining requests, it will automatically be disabled and is no longer valid unless you update it.
	Remaining *int64 `json:"remaining,omitempty"`
	// Unkey enables you to refill verifications for each key at regular intervals.
	Refill *V1MigrationsEnqueueKeysRefill `json:"refill,omitempty"`
	// Unkey comes with per-key fixed-window ratelimiting out of the box.
	Ratelimit *V1MigrationsEnqueueKeysRatelimit `json:"ratelimit,omitempty"`
	// Sets if key is enabled or disabled. Disabled keys are not valid.
	Enabled *bool `default:"true" json:"enabled"`
	// Environments allow you to divide your keyspace.
	//
	// Some applications like Stripe, Clerk, WorkOS and others have a concept of "live" and "test" keys to
	// give the developer a way to develop their own application without the risk of modifying real world
	// resources.
	//
	// When you set an environment, we will return it back to you when validating the key, so you can
	// handle it correctly.
	//
	Environment *string `json:"environment,omitempty"`
}

func (k Keys) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *Keys) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Keys) GetPrefix() *string {
	if o == nil {
		return nil
	}
	return o.Prefix
}

func (o *Keys) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Keys) GetPlaintext() *string {
	if o == nil {
		return nil
	}
	return o.Plaintext
}

func (o *Keys) GetHash() *V1MigrationsEnqueueKeysHash {
	if o == nil {
		return nil
	}
	return o.Hash
}

func (o *Keys) GetStart() *string {
	if o == nil {
		return nil
	}
	return o.Start
}

func (o *Keys) GetOwnerID() *string {
	if o == nil {
		return nil
	}
	return o.OwnerID
}

func (o *Keys) GetMeta() map[string]any {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *Keys) GetRoles() []string {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *Keys) GetPermissions() []string {
	if o == nil {
		return nil
	}
	return o.Permissions
}

func (o *Keys) GetExpires() *int64 {
	if o == nil {
		return nil
	}
	return o.Expires
}

func (o *Keys) GetRemaining() *int64 {
	if o == nil {
		return nil
	}
	return o.Remaining
}

func (o *Keys) GetRefill() *V1MigrationsEnqueueKeysRefill {
	if o == nil {
		return nil
	}
	return o.Refill
}

func (o *Keys) GetRatelimit() *V1MigrationsEnqueueKeysRatelimit {
	if o == nil {
		return nil
	}
	return o.Ratelimit
}

func (o *Keys) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *Keys) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

type V1MigrationsEnqueueKeysRequestBody struct {
	// Contact support@unkey.dev to receive your migration id.
	MigrationID string `json:"migrationId"`
	// The id of the api, you want to migrate keys to
	APIID string `json:"apiId"`
	Keys  []Keys `json:"keys"`
}

func (o *V1MigrationsEnqueueKeysRequestBody) GetMigrationID() string {
	if o == nil {
		return ""
	}
	return o.MigrationID
}

func (o *V1MigrationsEnqueueKeysRequestBody) GetAPIID() string {
	if o == nil {
		return ""
	}
	return o.APIID
}

func (o *V1MigrationsEnqueueKeysRequestBody) GetKeys() []Keys {
	if o == nil {
		return []Keys{}
	}
	return o.Keys
}

// V1MigrationsEnqueueKeysResponseBody - The key ids of all created keys
type V1MigrationsEnqueueKeysResponseBody struct {
}

type V1MigrationsEnqueueKeysResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The key ids of all created keys
	Object *V1MigrationsEnqueueKeysResponseBody
}

func (o *V1MigrationsEnqueueKeysResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *V1MigrationsEnqueueKeysResponse) GetObject() *V1MigrationsEnqueueKeysResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
